<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ä»£ç†å³æ—¶èŠå¤©</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  <style>
    :root {
      --primary: #6c5ce7;
      --secondary: #00F0FF;
      --dark: #0b1220;
      --panel: rgba(15,23,42,0.72);
    }
    body { background: radial-gradient(circle at top,#192133 0%,#0b1220 55%,#070b12 100%); color: #e2e8f0; }
    .glass { background: var(--panel); backdrop-filter: blur(14px); border: 1px solid rgba(99,102,241,0.25); box-shadow: 0 10px 25px rgba(15,23,42,0.35); }
    .btn-primary { background: var(--primary); color:#fff; transition: opacity .2s ease; }
    .btn-primary:hover { opacity: .9; }
    .conversation-item { transition: background .15s ease; }
    .conversation-item:hover { background: rgba(255,255,255,0.08); }
    .conversation-item.active { background: rgba(99,102,241,0.28); border-color: rgba(99,102,241,0.6); }
    .message-bubble { max-width: 72%; border-radius: 1rem; padding: 0.65rem 0.95rem; margin-bottom: 0.6rem; line-height: 1.45; word-break: break-word; white-space: pre-wrap; }
    .message-self { margin-left: auto; background: linear-gradient(135deg, rgba(99,102,241,0.85), rgba(129,140,248,0.75)); color: #fff; box-shadow: 0 8px 16px rgba(99,102,241,0.35); }
    .message-other { margin-right: auto; background: rgba(30,41,59,0.85); border: 1px solid rgba(148,163,184,0.18); }
    .message-meta { font-size: 0.75rem; opacity: 0.7; margin-top: 0.25rem; }
    .badge-unread { min-width: 1.5rem; text-align:center; }
    .form-input { background: rgba(15,23,42,0.75); border: 1px solid rgba(148,163,184,0.25); border-radius: 0.6rem; padding: 0.55rem 0.75rem; color: inherit; }
    .form-input:focus { outline: none; border-color: rgba(99,102,241,0.6); box-shadow: 0 0 0 3px rgba(99,102,241,0.18); }
    #toast { transition: transform .25s ease, opacity .25s ease; }
    .member-chip { display: inline-flex; align-items: center; gap: 0.35rem; background: rgba(148,163,184,0.2); padding: 0.25rem 0.6rem; border-radius: 999px; font-size: 0.75rem; color: #e2e8f0; }
    .member-chip.owner { background: rgba(99,102,241,0.35); }
    .member-chip.self { background: rgba(16,185,129,0.35); }
    .member-chip button { color: inherit; }
    #emoji-panel { position: absolute; bottom: 100%; right: 0; background: rgba(15,23,42,0.95); border: 1px solid rgba(99,102,241,0.4); border-radius: 0.75rem; padding: 0.5rem; display: none; max-width: 240px; flex-wrap: wrap; gap: 0.35rem; }
    #emoji-panel.open { display: flex; }
    #emoji-panel button { font-size: 1.35rem; line-height: 1; padding: 0.25rem; background: transparent; }
    #pending-attachment { display: none; }
    #pending-attachment.active { display: flex; }
    #pending-attachment img { max-width: 120px; max-height: 120px; border-radius: 0.75rem; }
    #pending-attachment button { color: #f87171; }
    #sidebar { position: relative; }
    #sidebar-close { display: none; }
    #sidebar-toggle { display: none; }
    #sidebar-backdrop { display: none; }
    body.sidebar-open { overflow: hidden; }
    @media (max-width: 960px) {
      #sidebar { position: fixed; top: 0; left: 0; bottom: 0; width: min(320px, 90%); max-width: 90vw; transform: translateX(-105%); z-index: 50; border-radius: 0; height: 100vh; overflow-y: auto; padding-top: 3.5rem; }
      #sidebar.open { transform: translateX(0); }
      #sidebar-close { display: inline-flex; }
      #sidebar-toggle { display: inline-flex; }
      #sidebar-backdrop { position: fixed; inset: 0; background: rgba(2,6,23,0.55); z-index: 40; }
      #sidebar-backdrop.visible { display: block; }
      #chat-panel { min-height: 0; }
    }
    @media (min-width: 961px) {
      #sidebar-backdrop { display: none !important; }
    }
  </style>
</head>
<body class="min-h-screen">
  <div class="max-w-7xl mx-auto px-4 py-6 space-y-6">
    <div class="flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
      <div class="flex items-center gap-3">
        <button id="back-btn" class="px-3 py-2 glass rounded-lg"><i class="fa fa-arrow-left mr-1"></i>è¿”å›é¢æ¿</button>
        <button id="sidebar-toggle" class="hidden lg:hidden px-3 py-2 glass rounded-lg text-sm"><i class="fa fa-comments mr-1"></i>ä¼šè¯åˆ—è¡¨</button>
        <div>
          <h1 class="text-2xl font-semibold text-white">ä»£ç†å³æ—¶èŠå¤©</h1>
          <p class="text-sm text-slate-400">ä¸æ‚¨çš„ä¸‹çº§ä»£ç†ä¿æŒå®æ—¶æ²Ÿé€š</p>
        </div>
      </div>
      <div class="flex items-center gap-3 text-sm text-slate-300">
        <span id="user-label" class="text-slate-200 hidden"></span>
        <button id="logout-btn" class="px-3 py-2 glass rounded-lg"><i class="fa fa-sign-out-alt mr-1"></i>é€€å‡ºç™»å½•</button>
      </div>
    </div>

    <div class="grid gap-4 lg:grid-cols-[320px,1fr]">
      <aside class="glass rounded-2xl p-4 space-y-4 relative" id="sidebar">
        <button id="sidebar-close" class="hidden absolute top-3 right-3 px-2 py-1 rounded-full bg-slate-900/70 text-slate-200 hover:text-white lg:hidden"><i class="fa fa-times"></i></button>
        <div>
          <label class="block text-sm text-slate-300 mb-2">é€‰æ‹©è½¯ä»¶ä½</label>
          <select id="software-select" class="form-input w-full"></select>
        </div>
        <div class="flex items-center justify-between">
          <button id="refresh-conversations" class="px-3 py-2 glass rounded-lg text-sm"><i class="fa fa-rotate mr-1"></i>åˆ·æ–°ä¼šè¯</button>
          <span id="conversation-summary" class="text-xs text-slate-400"></span>
        </div>
        <div class="space-y-3">
          <div>
            <h2 class="text-sm font-semibold text-slate-200 mb-2 uppercase tracking-wide">æ–°å»ºç§èŠ</h2>
            <form id="direct-form" class="space-y-2">
              <select id="direct-user" class="form-input w-full"></select>
              <textarea id="direct-message" rows="2" placeholder="é¦–æ¡æ¶ˆæ¯å†…å®¹" class="form-input w-full"></textarea>
              <button type="submit" class="w-full py-2 rounded-lg btn-primary text-sm"><i class="fa fa-paper-plane mr-1"></i>å‘é€ç§èŠæ¶ˆæ¯</button>
            </form>
          </div>
          <div class="border-t border-white/10 pt-3">
            <h2 class="text-sm font-semibold text-slate-200 mb-2 uppercase tracking-wide">åˆ›å»ºç¾¤èŠ</h2>
            <form id="group-form" class="space-y-3">
              <input id="group-name" type="text" placeholder="ç¾¤èŠåç§°" class="form-input w-full" />
              <div class="space-y-2">
                <div id="group-selected-container" class="flex flex-wrap gap-2 min-h-[36px]"></div>
                <div class="flex items-center gap-2">
                  <button type="button" id="group-select-button" class="px-3 py-1.5 glass rounded-lg text-sm"><i class="fa fa-user-plus mr-1"></i>é€‰æ‹©æˆå‘˜</button>
                  <span id="group-select-hint" class="text-xs text-slate-500">å¯å¤šé€‰ä¸‹çº§ä»£ç†</span>
                </div>
              </div>
              <select id="group-participants" class="hidden" multiple></select>
              <button type="submit" class="w-full py-2 rounded-lg glass text-sm"><i class="fa fa-users mr-1"></i>åˆ›å»ºç¾¤èŠ</button>
            </form>
          </div>
        </div>
        <div class="border-t border-white/10 pt-4">
          <h2 class="text-sm font-semibold text-slate-200 mb-2 uppercase tracking-wide">ä¼šè¯åˆ—è¡¨</h2>
          <div id="conversation-empty" class="text-xs text-slate-400 hidden">æš‚æ— ä¼šè¯ï¼Œå¯é€šè¿‡ä¸Šæ–¹è¡¨å•åˆ›å»ºã€‚</div>
          <div id="conversation-list" class="flex flex-col gap-2 max-h-[420px] overflow-y-auto pr-1"></div>
        </div>
      </aside>

      <section class="glass rounded-2xl p-4 flex flex-col min-h-[520px]" id="chat-panel">
        <div id="conversation-placeholder" class="flex-1 flex items-center justify-center text-slate-400 text-sm">
          è¯·é€‰æ‹©å·¦ä¾§ä¼šè¯æˆ–æ–°å»ºèŠå¤©å¼€å§‹æ²Ÿé€š
        </div>
        <div id="conversation-container" class="hidden flex-1 flex flex-col">
          <div class="flex flex-wrap items-center justify-between gap-2 pb-3 border-b border-white/10">
            <div>
              <h2 id="conversation-title" class="text-xl font-semibold text-white"></h2>
              <div id="conversation-meta" class="text-xs text-slate-400 mt-1"></div>
              <div id="conversation-members" class="flex flex-wrap gap-2 mt-2"></div>
            </div>
            <button id="invite-button" class="px-3 py-1.5 glass rounded-lg text-sm hidden"><i class="fa fa-user-plus mr-1"></i>é‚€è¯·ä¸‹çº§ä»£ç†</button>
          </div>
          <div id="message-wrapper" class="flex-1 overflow-hidden flex flex-col">
            <div id="message-list" class="flex-1 overflow-y-auto py-4 space-y-2"></div>
            <div id="message-empty" class="text-sm text-slate-400 text-center hidden">æš‚æ— èŠå¤©è®°å½•</div>
          </div>
          <form id="send-message-form" class="mt-4 glass rounded-xl p-3 space-y-3">
            <label class="block text-sm text-slate-300">å‘é€æ¶ˆæ¯</label>
            <div class="relative">
              <textarea id="message-input" rows="3" placeholder="è¾“å…¥å†…å®¹åæŒ‰å‘é€" class="form-input w-full"></textarea>
              <div id="emoji-panel"></div>
            </div>
            <div id="pending-attachment" class="items-center gap-3 rounded-lg bg-white/5 px-3 py-2">
              <img id="pending-attachment-preview" alt="å¾…å‘é€å›¾ç‰‡é¢„è§ˆ" />
              <div class="flex-1 text-xs text-slate-300">
                <div id="pending-attachment-name" class="font-medium text-slate-200"></div>
                <div id="pending-attachment-size" class="text-slate-400 mt-0.5"></div>
              </div>
              <button type="button" id="remove-attachment" class="px-2 py-1 glass rounded-lg text-xs"><i class="fa fa-times mr-1"></i>ç§»é™¤</button>
            </div>
            <div class="flex flex-wrap items-center justify-between gap-3">
              <div class="flex items-center gap-2 text-xs text-slate-400">
                <button type="button" id="attach-image-button" class="px-3 py-1.5 glass rounded-lg text-xs hidden"><i class="fa fa-image mr-1"></i>æ·»åŠ å›¾ç‰‡</button>
                <button type="button" id="emoji-button" class="px-3 py-1.5 glass rounded-lg text-xs hidden"><i class="fa fa-face-smile mr-1"></i>è¡¨æƒ…</button>
              </div>
              <span id="send-message-hint" class="text-xs text-slate-500">æ¶ˆæ¯å°†åœ¨ 24 å°æ—¶åè‡ªåŠ¨æ¸…ç†ï¼ˆå¯åœ¨é…ç½®ä¸­è°ƒæ•´ï¼‰ã€‚</span>
              <button type="submit" class="px-4 py-2 rounded-lg btn-primary text-sm"><i class="fa fa-paper-plane mr-1"></i>å‘é€</button>
            </div>
            <input type="file" id="image-input" accept="image/*" class="hidden" />
          </form>
        </div>
      </section>
    </div>
  </div>

  <div id="toast" class="fixed top-5 right-5 glass px-4 py-3 rounded-lg flex items-center gap-3 transform translate-x-full opacity-0 z-50">
    <i id="toast-icon" class="fa fa-info-circle text-blue-400"></i>
    <span id="toast-message">æ“ä½œæˆåŠŸ</span>
  </div>

  <div id="sidebar-backdrop"></div>

  <script>
    const TOKEN_STORAGE_KEY = 'sp_agent_token';
    const TOKEN_EXPIRY_STORAGE_KEY = 'sp_agent_token_exp';
    const LEGACY_TOKEN_STORAGE_KEYS = ['sp-agent-token'];
    const LEGACY_TOKEN_EXPIRY_KEYS = ['sp-agent-token-expiry'];
    const API_BASE_URL = (() => {
      const override = window.API_BASE_URL_OVERRIDE;
      if (typeof override === 'string' && override.trim().length > 0) {
        return override.trim().replace(/\/$/, '');
      }
      if (window.location && window.location.origin) {
        return `${window.location.origin.replace(/\/$/, '')}/api`;
      }
      return '/api';
    })();

    let authToken = null;
    let authTokenExpiry = null;
    let currentUser = null;
    let softwares = [];
    let contacts = [];
    let selectedSoftware = '';
    let conversations = [];
    let selectedConversationId = '';
    let conversationTimer = null;
    let messageTimer = null;
    let chatSettings = { retentionHours: 24, allowImageMessages: false, allowEmojiPicker: false, maxImageSizeKb: 2048 };
    let groupSelectedMembers = new Set();
    let pendingImage = null;
    const emojiList = ['ğŸ˜€','ğŸ˜','ğŸ˜‚','ğŸ¤£','ğŸ˜Š','ğŸ˜','ğŸ˜','ğŸ˜¢','ğŸ˜­','ğŸ˜¡','ğŸ‘','ğŸ‘','ğŸ™','ğŸ’ª','ğŸ‰','â¤ï¸','ğŸ”¥','ğŸš€','ğŸŒŸ','ğŸ’¡','ğŸ˜‰','ğŸ¤”','ğŸ˜´','ğŸ¤©'];
    let emojiPanelInitialized = false;

    const backBtn = document.getElementById('back-btn');
    const logoutBtn = document.getElementById('logout-btn');
    const userLabel = document.getElementById('user-label');
    const toast = document.getElementById('toast');
    const toastIcon = document.getElementById('toast-icon');
    const toastMessage = document.getElementById('toast-message');

    const softwareSelect = document.getElementById('software-select');
    const sidebar = document.getElementById('sidebar');
    const sidebarToggle = document.getElementById('sidebar-toggle');
    const sidebarCloseBtn = document.getElementById('sidebar-close');
    const sidebarBackdrop = document.getElementById('sidebar-backdrop');
    const MOBILE_BREAKPOINT = 960;
    const conversationListEl = document.getElementById('conversation-list');
    const conversationEmptyEl = document.getElementById('conversation-empty');
    const conversationSummary = document.getElementById('conversation-summary');
    const refreshConversationsBtn = document.getElementById('refresh-conversations');

    const conversationPlaceholder = document.getElementById('conversation-placeholder');
    const conversationContainer = document.getElementById('conversation-container');
    const conversationTitleEl = document.getElementById('conversation-title');
    const conversationMetaEl = document.getElementById('conversation-meta');
    const conversationMembersEl = document.getElementById('conversation-members');
    const inviteButton = document.getElementById('invite-button');
    const messageListEl = document.getElementById('message-list');
    const messageEmptyEl = document.getElementById('message-empty');
    const sendMessageForm = document.getElementById('send-message-form');
    const messageInput = document.getElementById('message-input');
    const sendMessageHint = document.getElementById('send-message-hint');
    const emojiPanel = document.getElementById('emoji-panel');
    const emojiButton = document.getElementById('emoji-button');
    const attachImageButton = document.getElementById('attach-image-button');
    const imageInput = document.getElementById('image-input');
    const pendingAttachmentEl = document.getElementById('pending-attachment');
    const pendingAttachmentPreview = document.getElementById('pending-attachment-preview');
    const pendingAttachmentName = document.getElementById('pending-attachment-name');
    const pendingAttachmentSize = document.getElementById('pending-attachment-size');
    const removeAttachmentButton = document.getElementById('remove-attachment');
    const sendButton = sendMessageForm.querySelector('button[type="submit"]');

    const directForm = document.getElementById('direct-form');
    const directUserSelect = document.getElementById('direct-user');
    const directMessageInput = document.getElementById('direct-message');
    const groupForm = document.getElementById('group-form');
    const groupNameInput = document.getElementById('group-name');
    const groupParticipantsSelect = document.getElementById('group-participants');
    const groupSelectButton = document.getElementById('group-select-button');
    const groupSelectedContainer = document.getElementById('group-selected-container');
    const groupSelectHint = document.getElementById('group-select-hint');

    updateRetentionHint();
    applyChatSettings();
    renderConversationMembers(null);

    function isMobileViewport() {
      return window.innerWidth <= MOBILE_BREAKPOINT;
    }

    function openSidebar() {
      if (!sidebar) return;
      sidebar.classList.add('open');
      document.body.classList.add('sidebar-open');
      if (sidebarBackdrop) sidebarBackdrop.classList.add('visible');
    }

    function closeSidebar() {
      if (!sidebar) return;
      sidebar.classList.remove('open');
      document.body.classList.remove('sidebar-open');
      if (sidebarBackdrop) sidebarBackdrop.classList.remove('visible');
    }

    function showToast(message, type = 'info') {
      toastMessage.textContent = message;
      toastIcon.className = type === 'error' ? 'fa fa-exclamation-circle text-red-400'
        : type === 'success' ? 'fa fa-check-circle text-green-400'
        : 'fa fa-info-circle text-blue-400';
      toast.classList.remove('translate-x-full');
      toast.classList.remove('opacity-0');
      toast.classList.add('opacity-100');
      setTimeout(() => {
        toast.classList.add('translate-x-full');
        toast.classList.add('opacity-0');
      }, 2200);
    }

    function setAuthToken(token, expiresAt) {
      authToken = token;
      if (token) {
        try {
          localStorage.setItem(TOKEN_STORAGE_KEY, token);
          LEGACY_TOKEN_STORAGE_KEYS.forEach(key => localStorage.removeItem(key));
        } catch (err) {
          console.warn('store token failed', err);
        }
      }
      if (expiresAt) {
        const parsed = Date.parse(expiresAt);
        if (!Number.isNaN(parsed)) {
          authTokenExpiry = parsed;
          try {
            localStorage.setItem(TOKEN_EXPIRY_STORAGE_KEY, new Date(parsed).toISOString());
            LEGACY_TOKEN_EXPIRY_KEYS.forEach(key => localStorage.removeItem(key));
          } catch (err) {
            console.warn('store token expiry failed', err);
          }
        }
      }
    }

    function clearAuthToken() {
      authToken = null;
      authTokenExpiry = null;
      try {
        localStorage.removeItem(TOKEN_STORAGE_KEY);
        localStorage.removeItem(TOKEN_EXPIRY_STORAGE_KEY);
        LEGACY_TOKEN_STORAGE_KEYS.forEach(key => localStorage.removeItem(key));
        LEGACY_TOKEN_EXPIRY_KEYS.forEach(key => localStorage.removeItem(key));
      } catch (err) {
        console.warn('clear token storage failed', err);
      }
    }

    function restoreTokenFromStorage() {
      try {
        let token = localStorage.getItem(TOKEN_STORAGE_KEY);
        if (!token) {
          for (const legacyKey of LEGACY_TOKEN_STORAGE_KEYS) {
            token = localStorage.getItem(legacyKey);
            if (token) {
              try { localStorage.setItem(TOKEN_STORAGE_KEY, token); } catch (err) { console.warn('migrate legacy token failed', err); }
              break;
            }
          }
        }
        if (token) authToken = token;
        let expires = localStorage.getItem(TOKEN_EXPIRY_STORAGE_KEY);
        if (!expires) {
          for (const legacyKey of LEGACY_TOKEN_EXPIRY_KEYS) {
            expires = localStorage.getItem(legacyKey);
            if (expires) {
              try { localStorage.setItem(TOKEN_EXPIRY_STORAGE_KEY, expires); } catch (err) { console.warn('migrate legacy expiry failed', err); }
              break;
            }
          }
        }
        if (expires) {
          const parsed = Date.parse(expires);
          if (!Number.isNaN(parsed)) {
            authTokenExpiry = parsed;
          }
        }
      } catch (err) {
        console.warn('restore token failed', err);
      }
    }

    function isTokenValid() {
      if (!authToken) return false;
      if (!authTokenExpiry) return true;
      return authTokenExpiry > Date.now();
    }

    function api(url, options = {}) {
      const headers = { 'Content-Type': 'application/json', ...(options.headers || {}) };
      if (authToken && isTokenValid()) {
        headers.Authorization = `Bearer ${authToken}`;
      }
      const config = { credentials: 'include', ...options, headers };
      return fetch(url, config).then(resp => {
        if (resp.status === 401) {
          handleUnauthorized();
        }
        return resp;
      });
    }

    function handleUnauthorized() {
      showToast('ç™»å½•çŠ¶æ€å·²å¤±æ•ˆï¼Œæ­£åœ¨è·³è½¬ç™»å½•é¡µâ€¦', 'error');
      clearAuthToken();
      setTimeout(() => { window.location.href = '/pages/index/index.html'; }, 800);
    }

    function formatTimestamp(value) {
      if (!value) return '';
      try {
        const date = new Date(value);
        return date.toLocaleString('zh-CN', { hour12: false });
      } catch {
        return value;
      }
    }

    function updateRetentionHint() {
      if (!sendMessageHint) return;
      const raw = Number(chatSettings?.retentionHours);
      const hours = Number.isFinite(raw) && raw > 0 ? Math.round(raw) : 24;
      let detail;
      if (hours % 24 === 0) {
        const days = hours / 24;
        detail = `${days} å¤©`;
      } else if (hours > 24) {
        const days = (hours / 24).toFixed(1).replace(/\.0$/, '');
        detail = `${hours} å°æ—¶ï¼ˆçº¦ ${days} å¤©ï¼‰`;
      } else {
        detail = `${hours} å°æ—¶`;
      }
      sendMessageHint.textContent = `æ¶ˆæ¯å°†åœ¨ ${detail} åè‡ªåŠ¨æ¸…ç†ï¼ˆå¯åœ¨é…ç½®ä¸­è°ƒæ•´ï¼‰ã€‚`;
    }

    function truncate(text, length = 60) {
      if (!text) return '';
      const normalized = text.trim();
      if (normalized.length <= length) return normalized;
      return normalized.slice(0, length) + 'â€¦';
    }

    async function loadCurrentUser() {
      try {
        const resp = await api(`${API_BASE_URL}/Auth/getUserInfo`, { method: 'POST' });
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const data = await resp.json();
        if (data?.code === 0) {
          currentUser = data.data || {};
          if (currentUser?.username) {
            userLabel.textContent = `å½“å‰ç™»å½•ï¼š${currentUser.username}`;
            userLabel.classList.remove('hidden');
          }
          return true;
        }
        showToast(data?.message || 'è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥', 'error');
        return false;
      } catch (err) {
        console.error('loadCurrentUser error', err);
        showToast('è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥ï¼š' + err.message, 'error');
        return false;
      }
    }

    async function loadChatSettings() {
      try {
        const resp = await api(`${API_BASE_URL}/Chat/settings`);
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const data = await resp.json();
        if (data?.code === 0 && data.data) {
          chatSettings = {
            retentionHours: data.data.retentionHours ?? chatSettings.retentionHours,
            allowImageMessages: !!data.data.allowImageMessages,
            allowEmojiPicker: !!data.data.allowEmojiPicker,
            maxImageSizeKb: data.data.maxImageSizeKb ?? chatSettings.maxImageSizeKb
          };
          updateRetentionHint();
          applyChatSettings();
        }
      } catch (err) {
        console.warn('loadChatSettings error', err);
        applyChatSettings();
      }
    }

    async function loadSoftwares() {
      try {
        const resp = await api(`${API_BASE_URL}/Software/GetSoftwareList`, { method: 'POST', body: JSON.stringify({}) });
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const data = await resp.json();
        const list = data?.data?.softwares || data?.data?.list || [];
        softwares = list;
        renderSoftwareOptions();
        if (softwares.length > 0) {
          selectedSoftware = softwares[0].softwareName || softwares[0].name || softwares[0];
          softwareSelect.value = selectedSoftware;
          await loadContacts();
          await loadConversations();
        } else {
          selectedSoftware = '';
          conversationSummary.textContent = 'æ— å¯ç”¨è½¯ä»¶ä½';
          renderConversationList();
          contacts = [];
          renderContactSelectors();
        }
      } catch (err) {
        console.error('loadSoftwares error', err);
        showToast('åŠ è½½è½¯ä»¶ä½å¤±è´¥ï¼š' + err.message, 'error');
      }
    }

    async function loadContacts() {
      if (!selectedSoftware) {
        contacts = [];
        renderContactSelectors();
        return;
      }

      try {
        const resp = await api(`${API_BASE_URL}/Chat/contacts?software=${encodeURIComponent(selectedSoftware)}`);
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const data = await resp.json();
        if (data?.code === 0) {
          contacts = data.data || [];
        } else {
          contacts = [];
          showToast(data?.message || 'åŠ è½½ä¸‹çº§ä»£ç†å¤±è´¥', 'error');
        }
      } catch (err) {
        console.error('loadContacts error', err);
        contacts = [];
        showToast('åŠ è½½ä¸‹çº§ä»£ç†å¤±è´¥ï¼š' + err.message, 'error');
      }

      renderContactSelectors();
    }

    function renderContactSelectors() {
      const previousDirect = directUserSelect.value;

      directUserSelect.innerHTML = '';
      groupParticipantsSelect.innerHTML = '';

      if (!contacts || contacts.length === 0) {
        const emptyOption = document.createElement('option');
        emptyOption.value = '';
        emptyOption.textContent = 'æš‚æ— å¯ç”¨ä¸‹çº§ä»£ç†';
        directUserSelect.appendChild(emptyOption);
        directUserSelect.disabled = true;

        groupParticipantsSelect.disabled = true;
        updateGroupSelectButtonState(false);
        groupSelectedMembers = new Set();
        renderGroupSelectedChips();
        return;
      }

      directUserSelect.disabled = false;
      groupParticipantsSelect.disabled = false;
      updateGroupSelectButtonState(true);

      const availableUsernames = new Set(
        contacts
          .map(contact => (contact.username || contact.Username || '').trim())
          .filter(Boolean)
      );

      groupSelectedMembers = new Set(Array.from(groupSelectedMembers).filter(name => availableUsernames.has(name)));

      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'è¯·é€‰æ‹©ä¸‹çº§ä»£ç†';
      placeholder.disabled = true;
      placeholder.selected = true;
      directUserSelect.appendChild(placeholder);

      contacts.forEach(contact => {
        const option = document.createElement('option');
        option.value = contact.username || contact.Username;
        option.textContent = contact.displayName || contact.DisplayName || option.value;
        directUserSelect.appendChild(option);

        const groupOption = document.createElement('option');
        groupOption.value = option.value;
        groupOption.textContent = option.textContent;
        groupOption.selected = groupSelectedMembers.has(groupOption.value);
        groupParticipantsSelect.appendChild(groupOption);
      });

      if (previousDirect) {
        const match = Array.from(directUserSelect.options).find(option => option.value === previousDirect);
        if (match) {
          directUserSelect.value = previousDirect;
        }
      }

      syncGroupSelectOptions();
      renderGroupSelectedChips();
    }

    function updateGroupSelectButtonState(hasContacts) {
      if (!groupSelectButton) return;
      groupSelectButton.disabled = !hasContacts;
      groupSelectButton.classList.toggle('opacity-50', !hasContacts);
      groupSelectButton.classList.toggle('cursor-not-allowed', !hasContacts);
    }

    function syncGroupSelectOptions() {
      Array.from(groupParticipantsSelect.options).forEach(option => {
        option.selected = groupSelectedMembers.has(option.value);
      });
    }

    function renderGroupSelectedChips() {
      if (!groupSelectedContainer) return;
      groupSelectedContainer.innerHTML = '';

      if (!groupSelectedMembers || groupSelectedMembers.size === 0) {
        const placeholder = document.createElement('span');
        placeholder.className = 'text-xs text-slate-500';
        placeholder.textContent = groupSelectButton?.disabled ? 'æš‚æ— å¯ç”¨ä¸‹çº§ä»£ç†' : 'å°šæœªé€‰æ‹©æˆå‘˜';
        groupSelectedContainer.appendChild(placeholder);
        updateGroupSelectHintText();
        return;
      }

      Array.from(groupSelectedMembers).forEach(username => {
        const chip = document.createElement('span');
        chip.className = 'member-chip';
        const display = getContactDisplayName(username) || username;
        const label = document.createElement('span');
        label.textContent = display;
        chip.appendChild(label);

        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'text-xs';
        removeBtn.innerHTML = '<i class="fa fa-times"></i>';
        removeBtn.addEventListener('click', () => {
          groupSelectedMembers.delete(username);
          syncGroupSelectOptions();
          renderGroupSelectedChips();
        });
        chip.appendChild(removeBtn);

        groupSelectedContainer.appendChild(chip);
      });

      updateGroupSelectHintText();
    }

    function updateGroupSelectHintText() {
      if (!groupSelectHint) return;
      if (!contacts || contacts.length === 0) {
        groupSelectHint.textContent = 'æš‚æ— å¯ç”¨ä¸‹çº§ä»£ç†';
        return;
      }

      if (!groupSelectedMembers || groupSelectedMembers.size === 0) {
        groupSelectHint.textContent = 'å¯å¤šé€‰ä¸‹çº§ä»£ç†';
      } else {
        groupSelectHint.textContent = `å·²é€‰æ‹© ${groupSelectedMembers.size} äºº`;
      }
    }

    function findContact(username) {
      if (!username) return null;
      const lower = String(username).toLowerCase();
      return contacts.find(contact => {
        const name = contact.username || contact.Username;
        return String(name).toLowerCase() === lower;
      }) || null;
    }

    function getContactDisplayName(username) {
      if (!username) return '';
      const contact = findContact(username);
      if (contact) {
        return contact.displayName || contact.DisplayName || username;
      }
      return username;
    }

    function applyChatSettings() {
      const allowImages = !!chatSettings?.allowImageMessages;
      const allowEmoji = !!chatSettings?.allowEmojiPicker;
      if (attachImageButton) {
        attachImageButton.classList.toggle('hidden', !allowImages);
      }
      if (!allowImages) {
        clearPendingAttachment();
      }
      if (emojiButton) {
        emojiButton.classList.toggle('hidden', !allowEmoji);
      }
      if (allowEmoji) {
        renderEmojiPanel();
      } else {
        closeEmojiPanel();
      }
      updateGroupSelectHintText();
      updatePendingAttachmentUI();
    }

    function renderEmojiPanel() {
      if (!emojiPanel || emojiPanelInitialized) {
        return;
      }

      emojiPanel.innerHTML = '';
      emojiList.forEach(emoji => {
        const button = document.createElement('button');
        button.type = 'button';
        button.textContent = emoji;
        button.addEventListener('click', () => {
          insertEmoji(emoji);
          closeEmojiPanel();
        });
        emojiPanel.appendChild(button);
      });

      emojiPanelInitialized = true;
    }

    function handleEmojiButtonClick(event) {
      event.preventDefault();
      event.stopPropagation();
      if (emojiPanel && emojiPanel.classList.contains('open')) {
        closeEmojiPanel();
      } else {
        openEmojiPanel();
      }
    }

    function openEmojiPanel() {
      if (!emojiPanel || emojiButton?.classList.contains('hidden')) return;
      renderEmojiPanel();
      emojiPanel.classList.add('open');
    }

    function closeEmojiPanel() {
      if (!emojiPanel) return;
      emojiPanel.classList.remove('open');
    }

    function handleGlobalClick(event) {
      if (!emojiPanel || !emojiPanel.classList.contains('open')) return;
      if (emojiPanel.contains(event.target) || event.target === emojiButton) {
        return;
      }
      closeEmojiPanel();
    }

    function insertEmoji(emoji) {
      if (!messageInput) return;
      const value = messageInput.value || '';
      const start = messageInput.selectionStart ?? value.length;
      const end = messageInput.selectionEnd ?? start;
      messageInput.value = value.slice(0, start) + emoji + value.slice(end);
      const newPos = start + emoji.length;
      messageInput.focus();
      if (typeof messageInput.setSelectionRange === 'function') {
        messageInput.setSelectionRange(newPos, newPos);
      }
    }

    async function handleMessagePaste(event) {
      if (!chatSettings.allowImageMessages) {
        return;
      }

      const items = event.clipboardData?.items || [];
      for (const item of items) {
        if (item && item.type && item.type.startsWith('image/')) {
          const file = item.getAsFile();
          if (file) {
            event.preventDefault();
            await setPendingImageFromFile(file);
            return;
          }
        }
      }
    }

    function handleImageInputChange(event) {
      const file = event.target?.files?.[0];
      if (!file) {
        return;
      }

      setPendingImageFromFile(file);
      event.target.value = '';
    }

    async function setPendingImageFromFile(file) {
      if (!chatSettings.allowImageMessages) {
        showToast('å›¾ç‰‡å‘é€åŠŸèƒ½å·²å…³é—­', 'error');
        return;
      }

      const maxSize = Number(chatSettings.maxImageSizeKb || 2048) * 1024;
      if (file.size > maxSize) {
        showToast(`å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡ ${chatSettings.maxImageSizeKb || 2048} KB`, 'error');
        return;
      }

      try {
        const dataUrl = await readFileAsDataUrl(file);
        pendingImage = {
          base64: dataUrl,
          name: file.name || 'æˆªå›¾.png',
          size: file.size,
          preview: dataUrl
        };
        updatePendingAttachmentUI();
      } catch (err) {
        console.error('setPendingImageFromFile error', err);
        showToast('åŠ è½½å›¾ç‰‡å¤±è´¥ï¼š' + err.message, 'error');
      }
    }

    function clearPendingAttachment() {
      pendingImage = null;
      updatePendingAttachmentUI();
    }

    function updatePendingAttachmentUI() {
      if (!pendingAttachmentEl) return;
      if (!pendingImage || !chatSettings.allowImageMessages) {
        pendingAttachmentEl.classList.remove('active');
        return;
      }

      pendingAttachmentEl.classList.add('active');
      if (pendingAttachmentPreview) {
        pendingAttachmentPreview.src = pendingImage.preview;
      }
      if (pendingAttachmentName) {
        pendingAttachmentName.textContent = pendingImage.name || 'å›¾ç‰‡æ¶ˆæ¯';
      }
      if (pendingAttachmentSize) {
        pendingAttachmentSize.textContent = formatFileSize(pendingImage.size);
      }
    }

    function formatFileSize(bytes) {
      if (!Number.isFinite(bytes)) return '';
      const kb = bytes / 1024;
      if (kb < 1024) {
        return `${kb.toFixed(1)} KB`;
      }
      const mb = kb / 1024;
      return `${mb.toFixed(2)} MB`;
    }

    function readFileAsDataUrl(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          if (typeof reader.result === 'string') {
            resolve(reader.result);
          } else {
            reject(new Error('æ— æ³•è§£æå›¾ç‰‡æ•°æ®'));
          }
        };
        reader.onerror = () => reject(reader.error || new Error('è¯»å–æ–‡ä»¶å¤±è´¥'));
        reader.readAsDataURL(file);
      });
    }

    function openContactPicker({ title = 'é€‰æ‹©ä»£ç†', confirmText = 'ç¡®è®¤', multiple = false, exclude = [], preselected = [] } = {}) {
      const excludeSet = new Set((exclude || []).map(value => String(value).toLowerCase()));
      const preselectedSet = new Set((preselected || []).map(value => String(value).toLowerCase()));
      const available = contacts.filter(contact => {
        const name = contact.username || contact.Username;
        return !excludeSet.has(String(name).toLowerCase());
      });

      if (!available.length) {
        showToast('æš‚æ— å¯é‚€è¯·çš„ä¸‹çº§ä»£ç†', 'error');
        return Promise.resolve(null);
      }

      return new Promise(resolve => {
        const overlay = document.createElement('div');
        overlay.className = 'fixed inset-0 bg-black/60 flex items-center justify-center z-50 px-4';

        const panel = document.createElement('div');
        panel.className = 'glass rounded-2xl w-full max-w-md p-5 space-y-4';

        const heading = document.createElement('h3');
        heading.className = 'text-lg font-semibold text-white';
        heading.textContent = title;
        panel.appendChild(heading);

        const select = document.createElement('select');
        select.className = 'form-input w-full';
        select.multiple = multiple;
        if (multiple) {
          select.size = Math.min(Math.max(available.length, 4), 8);
        }

        if (!multiple) {
          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = 'è¯·é€‰æ‹©ä¸‹çº§ä»£ç†';
          placeholder.disabled = true;
          placeholder.selected = true;
          select.appendChild(placeholder);
        }

        available.forEach(contact => {
          const option = document.createElement('option');
          option.value = contact.username || contact.Username;
          option.textContent = contact.displayName || contact.DisplayName || option.value;
          if (multiple && preselectedSet.has(option.value.toLowerCase())) {
            option.selected = true;
          }
          select.appendChild(option);
        });

        if (!multiple && preselectedSet.size > 0) {
          const first = available.find(contact => preselectedSet.has(String(contact.username || contact.Username).toLowerCase()));
          if (first) {
            select.value = first.username || first.Username;
          }
        }

        panel.appendChild(select);

        const actions = document.createElement('div');
        actions.className = 'flex items-center justify-end gap-3';

        const cancelBtn = document.createElement('button');
        cancelBtn.type = 'button';
        cancelBtn.className = 'px-3 py-1.5 glass rounded-lg text-sm';
        cancelBtn.textContent = 'å–æ¶ˆ';
        cancelBtn.addEventListener('click', () => finalize(null));

        const confirmBtn = document.createElement('button');
        confirmBtn.type = 'button';
        confirmBtn.className = 'px-3 py-1.5 btn-primary rounded-lg text-sm';
        confirmBtn.textContent = confirmText;
        confirmBtn.addEventListener('click', () => {
          const values = multiple
            ? Array.from(select.selectedOptions || []).map(option => option.value).filter(Boolean)
            : [(select.value || '').trim()].filter(Boolean);
          if (values.length === 0) {
            showToast('è¯·è‡³å°‘é€‰æ‹©ä¸€ä½ä»£ç†', 'error');
            return;
          }
          finalize(values);
        });

        actions.appendChild(cancelBtn);
        actions.appendChild(confirmBtn);
        panel.appendChild(actions);

        let settled = false;
        function finalize(result) {
          if (settled) return;
          settled = true;
          if (overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
          }
          resolve(result);
        }

        overlay.addEventListener('click', (event) => {
          if (event.target === overlay) {
            finalize(null);
          }
        });

        overlay.appendChild(panel);
        document.body.appendChild(overlay);
      });
    }

    function renderSoftwareOptions() {
      softwareSelect.innerHTML = '';
      if (!softwares || softwares.length === 0) {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'æš‚æ— å¯ç”¨è½¯ä»¶ä½';
        softwareSelect.appendChild(option);
        softwareSelect.disabled = true;
        return;
      }
      softwareSelect.disabled = false;
      softwares.forEach(item => {
        const name = item.softwareName || item.name || item;
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        softwareSelect.appendChild(option);
      });
    }

    function renderConversationList() {
      conversationListEl.innerHTML = '';
      if (!conversations || conversations.length === 0) {
        conversationEmptyEl.classList.remove('hidden');
        conversationSummary.textContent = '0 ä¸ªä¼šè¯';
        return;
      }
      conversationEmptyEl.classList.add('hidden');
      conversationSummary.textContent = `${conversations.length} ä¸ªä¼šè¯`;

      conversations
        .slice()
        .sort((a, b) => new Date(b.updatedAt || 0).getTime() - new Date(a.updatedAt || 0).getTime())
        .forEach(conversation => {
          const item = document.createElement('button');
          item.type = 'button';
          item.className = 'conversation-item glass w-full text-left px-3 py-2 rounded-xl border border-transparent';
          item.dataset.id = conversation.conversationId;

          const isActive = conversation.conversationId === selectedConversationId;
          if (isActive) item.classList.add('active');

          const title = document.createElement('div');
          title.className = 'flex items-center justify-between gap-2 text-sm text-slate-200';
          const displayName = getConversationDisplayName(conversation);
          title.innerHTML = `<span class="font-semibold">${displayName}</span>`;

          if (conversation.unreadCount > 0) {
            const badge = document.createElement('span');
            badge.className = 'badge-unread inline-flex items-center justify-center rounded-full bg-red-500 text-white text-xs px-2 py-0.5';
            badge.textContent = conversation.unreadCount > 99 ? '99+' : String(conversation.unreadCount);
            title.appendChild(badge);
          }

          const meta = document.createElement('div');
          meta.className = 'text-xs text-slate-400 mt-1';
          const preview = truncate(conversation.lastMessagePreview || 'æš‚æœªæœ‰æ¶ˆæ¯');
          const time = conversation.updatedAt ? formatTimestamp(conversation.updatedAt) : '';
          meta.textContent = `${preview}${time ? ' Â· ' + time : ''}`;

          item.appendChild(title);
          item.appendChild(meta);
          item.addEventListener('click', () => selectConversation(conversation.conversationId));
          conversationListEl.appendChild(item);
        });
    }

    function renderConversationMembers(conversation) {
      if (!conversationMembersEl) return;
      conversationMembersEl.innerHTML = '';

      if (!conversation || !conversation.participants || conversation.participants.length === 0) {
        conversationMembersEl.classList.add('hidden');
        return;
      }

      conversationMembersEl.classList.remove('hidden');
      const current = (currentUser && currentUser.username) || '';
      const members = conversation.participants.slice();
      members.forEach(username => {
        const chip = document.createElement('span');
        chip.className = 'member-chip';
        if (conversation.owner && equalsIgnoreCase(conversation.owner, username)) {
          chip.classList.add('owner');
        }
        if (equalsIgnoreCase(current, username)) {
          chip.classList.add('self');
        }
        const displayName = getContactDisplayName(username) || username;
        const label = document.createElement('span');
        label.textContent = equalsIgnoreCase(current, username) ? `${displayName}ï¼ˆæˆ‘ï¼‰` : displayName;
        chip.appendChild(label);
        if (conversation.owner && equalsIgnoreCase(conversation.owner, username)) {
          const ownerTag = document.createElement('span');
          ownerTag.className = 'text-[10px] uppercase tracking-wide text-slate-200 bg-white/10 px-1.5 py-0.5 rounded-full';
          ownerTag.textContent = 'ç¾¤ä¸»';
          chip.appendChild(ownerTag);
        }
        conversationMembersEl.appendChild(chip);
      });
    }

    function getConversationDisplayName(conversation) {
      if (!conversation) return '';
      if (conversation.isGroup) {
        return conversation.groupName || 'ç¾¤èŠ';
      }
      const participants = conversation.participants || [];
      const current = (currentUser && currentUser.username) || '';
      const other = participants.find(name => !equalsIgnoreCase(name, current));
      return getContactDisplayName(other) || other || participants[0] || 'ç§èŠ';
    }

    function equalsIgnoreCase(a, b) {
      if (a === undefined || b === undefined) return false;
      return String(a).toLowerCase() === String(b).toLowerCase();
    }

    function buildAttachmentUrl(conversationId, fileName) {
      if (!fileName || !selectedSoftware) return '';
      const convo = conversationId || selectedConversationId;
      return `${API_BASE_URL}/Chat/attachment?software=${encodeURIComponent(selectedSoftware)}&conversationId=${encodeURIComponent(convo)}&file=${encodeURIComponent(fileName)}`;
    }

    async function loadConversations({ silent = false } = {}) {
      if (!selectedSoftware) {
        conversations = [];
        renderConversationList();
        return;
      }

      try {
        const resp = await api(`${API_BASE_URL}/Chat/conversations?software=${encodeURIComponent(selectedSoftware)}`);
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const data = await resp.json();
        if (data?.code === 0) {
          conversations = data.data || [];
          renderConversationList();
          if (!selectedConversationId && conversations.length > 0) {
            selectConversation(conversations[0].conversationId);
          } else if (selectedConversationId && conversations.every(c => c.conversationId !== selectedConversationId)) {
            selectedConversationId = '';
            toggleConversationPanel();
          }
        } else if (!silent) {
          showToast(data?.message || 'åŠ è½½ä¼šè¯å¤±è´¥', 'error');
        }
      } catch (err) {
        console.error('loadConversations error', err);
        if (!silent) {
          showToast('åŠ è½½ä¼šè¯å¤±è´¥ï¼š' + err.message, 'error');
        }
      }
    }

    async function loadMessages({ silent = false } = {}) {
      if (!selectedSoftware || !selectedConversationId) {
        return;
      }

      try {
        const resp = await api(`${API_BASE_URL}/Chat/messages?software=${encodeURIComponent(selectedSoftware)}&conversationId=${encodeURIComponent(selectedConversationId)}&limit=200`);
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const data = await resp.json();
        if (data?.code === 0) {
          const payload = data.data || {};
          updateConversationFromPayload(payload.conversation);
          renderConversationList();
          renderMessages(payload.messages || []);
        } else if (!silent) {
          showToast(data?.message || 'åŠ è½½æ¶ˆæ¯å¤±è´¥', 'error');
        }
      } catch (err) {
        console.error('loadMessages error', err);
        if (!silent) {
          showToast('åŠ è½½æ¶ˆæ¯å¤±è´¥ï¼š' + err.message, 'error');
        }
      }
    }

    function renderMessages(messages) {
      messageListEl.innerHTML = '';
      if (!messages || messages.length === 0) {
        messageEmptyEl.classList.remove('hidden');
        return;
      }

      messageEmptyEl.classList.add('hidden');
      const current = (currentUser && currentUser.username) || '';
      messages.forEach(msg => {
        const wrapper = document.createElement('div');
        const isSelf = equalsIgnoreCase(msg.sender, current);
        wrapper.className = `message-bubble ${isSelf ? 'message-self' : 'message-other'}`;

        if (msg.type === 'image' && msg.content) {
          const figure = document.createElement('figure');
          figure.className = 'space-y-2';
          const image = document.createElement('img');
          image.src = buildAttachmentUrl(selectedConversationId, msg.content);
          image.alt = msg.caption || 'å›¾ç‰‡æ¶ˆæ¯';
          image.className = 'max-h-64 rounded-xl border border-white/20 cursor-pointer';
          image.addEventListener('click', () => window.open(image.src, '_blank'));
          figure.appendChild(image);
          if (msg.caption) {
            const caption = document.createElement('figcaption');
            caption.className = 'text-xs text-slate-200';
            caption.textContent = msg.caption;
            figure.appendChild(caption);
          }
          wrapper.appendChild(figure);
        } else {
          const body = document.createElement('div');
          body.textContent = msg.content || '';
          wrapper.appendChild(body);
        }

        const meta = document.createElement('div');
        meta.className = 'message-meta';
        const senderName = isSelf ? (getContactDisplayName(current) || current || 'æˆ‘') : getContactDisplayName(msg.sender);
        const parts = [senderName || msg.sender];
        if (msg.type === 'image') {
          parts.push('å›¾ç‰‡');
        }
        parts.push(formatTimestamp(msg.timestamp));
        meta.textContent = parts.filter(Boolean).join(' Â· ');
        wrapper.appendChild(meta);

        messageListEl.appendChild(wrapper);
      });

      messageListEl.scrollTop = messageListEl.scrollHeight;
    }

    function toggleConversationPanel() {
      if (selectedConversationId) {
        conversationPlaceholder.classList.add('hidden');
        conversationContainer.classList.remove('hidden');
      } else {
        conversationPlaceholder.classList.remove('hidden');
        conversationContainer.classList.add('hidden');
        renderConversationMembers(null);
      }
    }

    function updateConversationFromPayload(conversation) {
      if (!conversation) return;
      const idx = conversations.findIndex(c => c.conversationId === conversation.conversationId);
      if (idx >= 0) {
        conversations[idx] = { ...conversations[idx], ...conversation };
        if (conversation.conversationId === selectedConversationId) {
          renderConversationMembers(conversations[idx]);
        }
      } else {
        conversations.push(conversation);
        if (conversation.conversationId === selectedConversationId) {
          renderConversationMembers(conversation);
        }
      }
    }

    function selectConversation(conversationId) {
      if (!conversationId || conversationId === selectedConversationId) {
        return;
      }

      selectedConversationId = conversationId;
      const conversation = conversations.find(c => c.conversationId === conversationId);
      if (!conversation) {
        toggleConversationPanel();
        renderConversationList();
        return;
      }

      if (pendingImage) {
        clearPendingAttachment();
      }

      conversationTitleEl.textContent = getConversationDisplayName(conversation);
      const participants = conversation.participants || [];
      const participantNames = participants.map(name => getContactDisplayName(name) || name);
      const detail = conversation.isGroup
        ? `ç¾¤èŠ Â· æˆå‘˜ ${participantNames.length} äºº`
        : `ç§èŠ Â· æˆå‘˜ ${participantNames.join('ã€')}`;
      const updatedAtText = conversation.updatedAt ? formatTimestamp(conversation.updatedAt) : '';
      conversationMetaEl.textContent = updatedAtText ? `${detail} Â· æœ€è¿‘æ›´æ–° ${updatedAtText}` : detail;
      renderConversationMembers(conversation);
      inviteButton.classList.toggle('hidden', !conversation.isGroup);
      inviteButton.dataset.id = conversation.conversationId;

      renderConversationList();
      toggleConversationPanel();
      loadMessages();
      restartMessageTimer();
      if (isMobileViewport()) {
        closeSidebar();
      }
    }

    function restartConversationTimer() {
      if (conversationTimer) {
        clearInterval(conversationTimer);
      }
      conversationTimer = setInterval(() => loadConversations({ silent: true }), 30000);
    }

    function restartMessageTimer() {
      if (messageTimer) {
        clearInterval(messageTimer);
      }
      if (!selectedConversationId) return;
      messageTimer = setInterval(() => loadMessages({ silent: true }), 3000);
    }

    async function handleSendMessage(event) {
      event.preventDefault();
      if (!selectedConversationId || !selectedSoftware) {
        showToast('è¯·å…ˆé€‰æ‹©ä¼šè¯', 'error');
        return;
      }
      const content = (messageInput.value || '').trim();
      const hasImage = !!pendingImage && !!chatSettings.allowImageMessages;
      if (!hasImage && !content) {
        showToast('æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º', 'error');
        return;
      }
      const payload = {
        software: selectedSoftware,
        conversationId: selectedConversationId,
        message: content
      };
      if (hasImage) {
        payload.messageType = 'image';
        payload.mediaBase64 = pendingImage.base64;
        payload.mediaName = pendingImage.name;
      }
      try {
        if (sendButton) sendButton.disabled = true;
        const resp = await api(`${API_BASE_URL}/Chat/send`, {
          method: 'POST',
          body: JSON.stringify(payload)
        });
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const data = await resp.json();
        if (data?.code === 0) {
          messageInput.value = '';
          if (hasImage) {
            clearPendingAttachment();
          }
          updateConversationFromPayload(data.data?.conversation);
          renderConversationList();
          renderMessages(data.data?.messages || []);
          loadConversations({ silent: true });
        } else {
          showToast(data?.message || 'å‘é€æ¶ˆæ¯å¤±è´¥', 'error');
        }
      } catch (err) {
        console.error('handleSendMessage error', err);
        showToast('å‘é€æ¶ˆæ¯å¤±è´¥ï¼š' + err.message, 'error');
      } finally {
        if (sendButton) sendButton.disabled = false;
      }
    }

    async function handleDirectForm(event) {
      event.preventDefault();
      if (!selectedSoftware) {
        showToast('è¯·å…ˆé€‰æ‹©è½¯ä»¶ä½', 'error');
        return;
      }
      const target = (directUserSelect.value || '').trim();
      const content = (directMessageInput.value || '').trim();
      if (!target) {
        showToast('è¯·é€‰æ‹©ä¸‹çº§ä»£ç†', 'error');
        return;
      }
      if (!content) {
        showToast('è¯·å¡«å†™é¦–æ¡æ¶ˆæ¯å†…å®¹', 'error');
        return;
      }
      try {
        const resp = await api(`${API_BASE_URL}/Chat/send`, {
          method: 'POST',
          body: JSON.stringify({ software: selectedSoftware, targetUser: target, message: content })
        });
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const data = await resp.json();
        if (data?.code === 0) {
          directUserSelect.selectedIndex = 0;
          directMessageInput.value = '';
          updateConversationFromPayload(data.data?.conversation);
          renderConversationList();
          selectConversation(data.data?.conversation?.conversationId);
          showToast('ç§èŠæ¶ˆæ¯å‘é€æˆåŠŸ', 'success');
        } else {
          showToast(data?.message || 'å‘é€å¤±è´¥', 'error');
        }
      } catch (err) {
        console.error('handleDirectForm error', err);
        showToast('å‘é€å¤±è´¥ï¼š' + err.message, 'error');
      }
    }

    async function handleGroupSelectClick() {
      if (!contacts || contacts.length === 0) {
        showToast('æš‚æ— å¯ç”¨ä¸‹çº§ä»£ç†', 'error');
        return;
      }

      const preselected = Array.from(groupSelectedMembers);
      const participants = await openContactPicker({
        title: 'é€‰æ‹©ç¾¤æˆå‘˜',
        confirmText: 'ç¡®å®š',
        multiple: true,
        preselected
      });

      if (!participants || participants.length === 0) {
        return;
      }

      groupSelectedMembers = new Set(participants);
      syncGroupSelectOptions();
      renderGroupSelectedChips();
    }

    async function handleGroupForm(event) {
      event.preventDefault();
      if (!selectedSoftware) {
        showToast('è¯·å…ˆé€‰æ‹©è½¯ä»¶ä½', 'error');
        return;
      }
      const name = (groupNameInput.value || '').trim();
      if (!name) {
        showToast('ç¾¤èŠåç§°ä¸èƒ½ä¸ºç©º', 'error');
        return;
      }
      const participants = Array.from(groupSelectedMembers);
      if (participants.length === 0) {
        showToast('è¯·è‡³å°‘é€‰æ‹©ä¸€ä½ä¸‹çº§ä»£ç†', 'error');
        return;
      }
      try {
        const resp = await api(`${API_BASE_URL}/Chat/groups`, {
          method: 'POST',
          body: JSON.stringify({ software: selectedSoftware, name, participants })
        });
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const data = await resp.json();
        if (data?.code === 0) {
          groupNameInput.value = '';
          groupSelectedMembers = new Set();
          syncGroupSelectOptions();
          renderGroupSelectedChips();
          updateConversationFromPayload(data.data);
          renderConversationList();
          selectConversation(data.data?.conversationId);
          showToast('ç¾¤èŠåˆ›å»ºæˆåŠŸ', 'success');
        } else {
          showToast(data?.message || 'åˆ›å»ºç¾¤èŠå¤±è´¥', 'error');
        }
      } catch (err) {
        console.error('handleGroupForm error', err);
        showToast('åˆ›å»ºç¾¤èŠå¤±è´¥ï¼š' + err.message, 'error');
      }
    }

    async function handleInvite() {
      const conversation = conversations.find(c => c.conversationId === selectedConversationId);
      if (!conversation) {
        showToast('è¯·å…ˆé€‰æ‹©ç¾¤èŠ', 'error');
        return;
      }
      const exclude = conversation.participants || [];
      const participants = await openContactPicker({
        title: 'é€‰æ‹©è¦é‚€è¯·çš„ä¸‹çº§ä»£ç†',
        confirmText: 'é‚€è¯·',
        multiple: true,
        exclude
      });
      if (!participants || participants.length === 0) {
        return;
      }
      try {
        const resp = await api(`${API_BASE_URL}/Chat/groups/${encodeURIComponent(conversation.conversationId)}/invite`, {
          method: 'POST',
          body: JSON.stringify({ software: selectedSoftware, participants })
        });
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const data = await resp.json();
        if (data?.code === 0) {
          updateConversationFromPayload(data.data);
          renderConversationList();
          selectConversation(data.data?.conversationId);
          showToast('é‚€è¯·æˆåŠŸ', 'success');
        } else {
          showToast(data?.message || 'é‚€è¯·å¤±è´¥', 'error');
        }
      } catch (err) {
        console.error('handleInvite error', err);
        showToast('é‚€è¯·å¤±è´¥ï¼š' + err.message, 'error');
      }
    }

    async function logout() {
      try {
        await api(`${API_BASE_URL}/Auth/logout`, { method: 'POST' });
      } catch (err) {
        console.warn('logout error', err);
      } finally {
        clearAuthToken();
        window.location.href = '/pages/index/index.html';
      }
    }

    function stopAllTimers() {
      if (conversationTimer) {
        clearInterval(conversationTimer);
        conversationTimer = null;
      }
      if (messageTimer) {
        clearInterval(messageTimer);
        messageTimer = null;
      }
    }

    function initEvents() {
      backBtn.addEventListener('click', () => window.location.href = '/pages/index/index.html');
      logoutBtn.addEventListener('click', logout);
      softwareSelect.addEventListener('change', async (event) => {
        selectedSoftware = event.target.value;
        selectedConversationId = '';
        renderConversationList();
        toggleConversationPanel();
        await loadContacts();
        await loadConversations();
      });
      refreshConversationsBtn.addEventListener('click', () => loadConversations());
      sendMessageForm.addEventListener('submit', handleSendMessage);
      directForm.addEventListener('submit', handleDirectForm);
      if (groupSelectButton) {
        groupSelectButton.addEventListener('click', handleGroupSelectClick);
      }
      groupForm.addEventListener('submit', handleGroupForm);
      inviteButton.addEventListener('click', handleInvite);
      if (sidebarToggle) {
        sidebarToggle.addEventListener('click', (event) => {
          event.preventDefault();
          openSidebar();
        });
      }
      if (sidebarCloseBtn) {
        sidebarCloseBtn.addEventListener('click', (event) => {
          event.preventDefault();
          closeSidebar();
        });
      }
      if (sidebarBackdrop) {
        sidebarBackdrop.addEventListener('click', () => closeSidebar());
      }
      if (attachImageButton) {
        attachImageButton.addEventListener('click', () => imageInput && imageInput.click());
      }
      if (imageInput) {
        imageInput.addEventListener('change', handleImageInputChange);
      }
      if (removeAttachmentButton) {
        removeAttachmentButton.addEventListener('click', () => clearPendingAttachment());
      }
      if (messageInput) {
        messageInput.addEventListener('paste', handleMessagePaste);
      }
      if (emojiButton) {
        emojiButton.addEventListener('click', handleEmojiButtonClick);
      }
      document.addEventListener('click', handleGlobalClick);
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          closeSidebar();
        }
      });
      window.addEventListener('resize', () => {
        if (!isMobileViewport()) {
          closeSidebar();
        }
      });
      window.addEventListener('beforeunload', stopAllTimers);
    }

    async function bootstrap() {
      restoreTokenFromStorage();
      if (!isTokenValid()) {
        handleUnauthorized();
        return;
      }
      initEvents();
      const ok = await loadCurrentUser();
      if (!ok) {
        return;
      }
      await loadChatSettings();
      await loadSoftwares();
      restartConversationTimer();
      restartMessageTimer();
    }

    bootstrap();
  </script>
</body>
</html>
